<html>
<body>
	<span id="countdown_lbl"></span>
	<br>
	<div id="my_camera"></div>
	<input type="button" value="Start" onClick="CountdownLbl.run(start_snapping)">
	<input type="button" value="Predict" onClick="predictFromSnaps()">
	<div id="results"><p>Your captured images will appear here...</p></div>


	<script src="https://cdnjs.cloudflare.com/ajax/libs/webcamjs/1.0.25/webcam.min.js"></script>
	<script src="vendor/tf.min.js"></script>

	<script>
		Webcam.set({
			width: 134,
			height: 100,
			image_format: 'jpeg',
			jpeg_quality: 100
		})
		Webcam.attach('#my_camera')
	</script>
	<script>
		const CountdownLbl = {
			elem: document.getElementById('countdown_lbl'),
			run: function(callback) {
				let count = 3
				// erase snaps
				document.getElementById('results').innerHTML = ''

				const countdown = () => {
					if (count === 0) {
						this.update('Go!')
						clearInterval(interval)
						callback()
						setTimeout(() => {
							// go invisible
							this.update()
						}, 250)
					} else {
						this.update(count)
					}
					--count
				}
				const interval = setInterval(countdown, 1000)
				countdown()
			},
			update: function(count = '') {
				this.elem.innerText = count
			}
		}
	</script>

	<script>
		let timer = null
		let timer_cnt = 0

		function take_snapshot() {
			// take snapshot and get image data
			Webcam.snap(function(data_uri) {
				// display results in page
				let img = new Image()
				img.src = data_uri

				document.getElementById('results').appendChild(img)

				timer_cnt += 1
				if (timer_cnt >= 30) {
					clearInterval(timer)
					timer = null
					timer_cnt = 0
				}
			})
		}

		function start_snapping() {
			if (!timer) {
				timer_cnt = 0
				timer = setInterval(take_snapshot, 1000/12)
			}
		}


		const LABELS = [
			'Drumming Fingers',
			'Stop Sign',
			'Swiping Left',
			'Swiping Right',
			'Thumb Down',
			'Thumb Up',
			'Turning Hand Clockwise',
		]

		// Pre-processing
		// ----------------------------------------
		function extract(img) {
			// Use tidy to automatically clean up intermediate tensors
			return tf.tidy(() => {
				// Convert the image data to a tensor
				let tensor = tf.fromPixels(img, numChannels = 1)

				// resize to 80 x 80
				const resized = tf.image.resizeBilinear(tensor, [80, 80]).toFloat()

				// Normalize the image
				const offset = tf.scalar(255.0)

				const normalized = resized.div(offset)
				return normalized
			})
		}


		function preprocess(images) {
			const sequence = tf
				.stack(images.map(img => extract(img)), 0)
				.squeeze()
				.expandDims(0)

			return sequence
		}



		function predictFromSnaps() {
			const imgCollection = document.getElementById('results').getElementsByTagName('img')
			let images = []
			for (const image of imgCollection) {
				images.push(image)
			}

			const data = preprocess(images)

			const prediction = model.predict(data, { verbose: true })
			const predResults = prediction.dataSync()
			const labelledResults = LABELS
				.map((l, i) => [l, predResults[i]])
				.sort((a, b) => a[1] < b[1])
			console.log(labelledResults.map(a => a.join(': ')))
		}



		// MAIN
		// ----------------------------------------
		tf.loadModel('models/conv_3d_grayscale/model.json')
			.then(model => {
				console.log(model)
				window.model = model
			})

	</script>
</body>
</html>
