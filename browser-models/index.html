<html>
<head>
	<style>
		button {
			cursor: pointer;
			margin: 2px;
			padding: 8px 16px;
		}
		td {
			width: 16px;
		}
		th {
			text-align: left;
			font-size: .8em;
		}
		.columns {
			display: flex;
			justify-content: space-between;
		}
		.columns > div {
			flex: 1 0 auto;
		}
	</style>
</head>
<body>
	<main>
		<div class="columns">
			<div></div>
			<div>
				<div id="my_camera"></div>
				<span>
					Countdown:
					<b><span id="countdown_lbl"></span></b>
				</span>
			</div>
			<div>
				<p id="model_type_label"></p>
				<p id="current_sign">Performing: -</p>
			</div>
		</div>
		<!-- <canvas width="134" height="100" id="my_canvas"></canvas> -->
		<!-- <input type="button" value="Record and Predict!" onClick="CountdownLbl.run(start_snapping)"> -->
		<h3 style="margin-bottom: 2px">I am going to perform the sign:</h3>
		<div style="display: none" id="feedback_btns"></div>
		<div id="results"><p>Your captured images will appear here...</p></div>
		<div class="columns">
			<div id="analysis_results"></div>
			<div id="prediction_results"></div>
		</div>
	</main>

	<script src="https://cdnjs.cloudflare.com/ajax/libs/webcamjs/1.0.25/webcam.min.js"></script>
	<script src="vendor/tf.min.js"></script>

	<script>
		Webcam.set({
			width: 134,
			height: 100,
			image_format: 'jpeg',
			jpeg_quality: 100
		})
		Webcam.attach('#my_camera')
	</script>
	<script>
		const CountdownLbl = {
			elem: document.getElementById('countdown_lbl'),
			run: function(callback) {
				let count = 3
				// erase snaps
				document.getElementById('results').innerHTML = ''

				const countdown = () => {
					if (count === 0) {
						this.update('Go!')
						clearInterval(interval)
						callback()
						setTimeout(() => {
							// go invisible
							this.update()
						}, 250)
					} else {
						this.update(count)
					}
					--count
				}
				const interval = setInterval(countdown, 1000)
				countdown()
			},
			update: function(count = '') {
				this.elem.innerText = count
			}
		}
	</script>
	<script>
		let timer = null
		let timer_cnt = 0

		const LABELS = [
			'Drumming Fingers',
			'Stop Sign',
			'Swiping Left',
			'Swiping Right',
			'Thumb Down',
			'Thumb Up',
			'Turning Hand Clockwise',
		]

		let currentPrediction = ''
		const confMatrix = {}

		for (const l of LABELS) {
			confMatrix[l] = {}
			for (const l2 of LABELS) {
				confMatrix[l][l2] = 0
			}

			const btn = document.createElement('button')
			btn.innerText = l
			btn.onclick = () => {
				document.getElementById('current_sign').innerText = 'Performing: ' + l
				CountdownLbl.run(start_snapping)
				currentPrediction = l
			}
			document.getElementById('feedback_btns').appendChild(btn)
		}



		function giveFeedback(feedback) {
			confMatrix[currentPrediction][feedback] += 1

			displayConfusionMatrix()
		}

		function calculateAccuracy() {
			let correct = 0
			let total = 0

			for (const x of LABELS) {
				for (const y of LABELS) {
					if (x === y) {
						correct += confMatrix[x][y]
					}
					total += confMatrix[x][y]
				}
			}
			return correct / total
		}

		function displayConfusionMatrix() {
			const table = document.createElement('table')
			const tableBody = document.createElement('tbody')

			for (const x of LABELS) {
				const row = document.createElement('tr')
				const header = document.createElement('th')
				header.appendChild(document.createTextNode(x))
				row.appendChild(header)



				for (const y of LABELS) {
					const cell = document.createElement('td')
					cell.appendChild(document.createTextNode(confMatrix[x][y]))
					if (x === y) {
						cell.style.color = '#e00000'
					}
					row.appendChild(cell)
				}
				tableBody.appendChild(row)
			}
			table.appendChild(tableBody)
			const resultsElem = document.getElementById('analysis_results')
			resultsElem.innerHTML = '<h3>Confusion Matrix:</h3>'
			resultsElem.appendChild(table)
			const accuracyLabel = document.createElement('p')
			accuracyLabel.innerHTML = '<b>Total Accuracy:</b> ' + calculateAccuracy()
			resultsElem.appendChild(accuracyLabel)

		}

		function displayPredictions(predResults) {
			// print results
			const labelledResults = LABELS
				.map((l, i) => [l, predResults[i]])
				.sort((a, b) => b[1] - a[1])

			console.log(labelledResults
					.map(a => [a[0].padEnd(25), a[1].toFixed(3)])
					.map(a => a.join(': ')).join('\n'))

			giveFeedback(labelledResults[0][0])

			// predictions
			const table = document.createElement('table')
			const tableBody = document.createElement('tbody')

			for (const result of labelledResults) {
				const row = document.createElement('tr')
				const header = document.createElement('th')
				header.appendChild(document.createTextNode(result[0]))
				row.appendChild(header)

				const cell = document.createElement('td')
				cell.appendChild(document.createTextNode(result[1].toFixed(4)))
				row.appendChild(cell)

				tableBody.appendChild(row)
			}

			table.appendChild(tableBody)
			const elem = document.getElementById('prediction_results')
			elem.innerHTML = '<h3>Predicted results:</h3>'
			elem.appendChild(table)
		}


		function take_snapshot() {
			// take snapshot and get image data
			Webcam.snap(function(data_uri) {
				// display results in page
				let img = new Image()
				img.src = data_uri

				document.getElementById('results').appendChild(img)

				timer_cnt += 1
				if (timer_cnt >= 30) {
					clearInterval(timer)
					timer = null
					timer_cnt = 0

					// start predicting! (after I let the browser catch up)
					setTimeout(predictFromSnaps, 0)
				}
			})
		}

		function start_snapping() {
			if (!timer) {
				timer_cnt = 0
				timer = setInterval(take_snapshot, 1000/12)
			}
		}




		// Pre-processing
		// ----------------------------------------
		function extract(img) {
			// Use tidy to automatically clean up intermediate tensors
			return tf.tidy(() => {
				// Convert the image data to a tensor
				const tensor = tf.fromPixels(img, numChannels = 1)

				// DEBUG
				// tf.toPixels(tensor, document.getElementById('my_canvas'))

				// resize to 80 x 80
				const resized = tf.image.resizeBilinear(tensor, [80, 80]).toFloat()

				// Normalize the image
				const offset = tf.scalar(255.0)

				const normalized = resized.div(offset)

				return normalized
			})
		}


		function preprocess(images) {
			const sequence = tf
				.stack(images.map(img => extract(img)), 0)
				.squeeze()
				.expandDims(0)

			return sequence
		}



		function predictFromSnaps() {
			const startTime = performance.now()

			const imgCollection = document.getElementById('results').getElementsByTagName('img')
			let images = []
			for (const image of imgCollection) {
				images.push(image)
			}

			const data = preprocess(images)
			const prediction = model.predict(data, { verbose: true })
			const predResults = prediction.dataSync()

			const endTime = performance.now()

			displayPredictions(predResults)

			console.log('Prediction took ' + (endTime - startTime) + ' milliseconds!')
		}



		// MAIN
		// ----------------------------------------
		function getModelName() {

			const urlParams = new URLSearchParams(window.location.search)
			const modelName = urlParams.get('model')

			if (modelName === 'conv_3d_grayscale' || modelName === 'lrcn_gray') {
				return modelName
			} else {
				return 'conv_3d_grayscale'
			}
		}
		const MODEL_NAME = getModelName()
		document.getElementById('model_type_label').innerText = 'Model: ' + MODEL_NAME

		tf.loadModel(`models/${MODEL_NAME}/model.json`)
			.then(model => {
				window.model = model
				console.log('model is loaded!')
				document.getElementById('feedback_btns').style.display = 'block'
			})

	</script>
</body>
</html>
